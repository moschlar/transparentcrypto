<!-- https://github.com/almende/vis/blob/master/examples/network/24_hierarchical_layout_userdefined.html -->
<!-- http://visjs.org/docs/network.html -->
<!--
TODO: Unbekannte Schlüssel nur für eigene Keys
TODO: Statusbar mit Loading-Hinweis (x/y keys loaded)
-->
<html>
<head>

<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta charset="utf-8">

<script type="text/javascript" charset="utf-8" src="./lib/async.js"></script>
<script type="text/javascript" charset="utf-8" src="./lib/vis.min.js"></script>
<link href="./lib/vis.min.css" rel="stylesheet" type="text/css" />

<script type="text/javascript">
	try {
		Components.utils.import("resource://transparentcrypto/util.jsm");
		Components.utils.import("resource://transparentcrypto/keys.jsm");
		Components.utils.import("resource://enigmail/enigmailCommon.jsm");
		Components.utils.import("resource://enigmail/commonFuncs.jsm");
	} catch (ex) {Components.utils.reportError(ex); log(ex);}

	var gKeyList = [];
	var gKeySortList = [];

	var hoverNode = null;

	var network = undefined;

	var data = {
		nodes: new vis.DataSet(),
		edges: new vis.DataSet(),
	};

	var options = {
		nodes: {
			shape: "box",
			color: "gray",
			allowedToMoveX: true,
			allowedToMoveY: true,
		},
		edges: {
			style: "arrow",
			inheritColor: "from",
			widthSelectionMultiplier: 1.5,
			color: {
			color: "#848484",
			highlight: "#000000",
			},
		},
		groups: { // http://colorbrewer2.org/?type=diverging&scheme=RdYlGn&n=7
			u: { // ultimately valid
			color: "#1a9850",
			},
			f: { // fully valid
			color: "#91cf60",
			},
			m: { // marginal valid
			color: "#d9ef8b",
			},
			n: { // valid
			color: "#ffffbf",
			},
			q: { // undefined
			color: "#fee08b",
			},
			"-": { // unknown
			color: "#fee08b",
			},
			e: { // expired
			color: "#fc8d59",
			},
			r: { // revoked
			color: "#fc8d59",
			},
			d: { // disabled
			color: "#fc8d59",
			},
			i: { // invalid
			color: "#d73027",
			},
			o: { // unknown
			color: "#d73027",
			},
		},
		hover: true,
		hierarchicalLayout: {
			enabled: true,
			nodeSpacing: 300,
		},
		stabilize: true,
		smoothCurves: true,
		physics: {
			hierarchicalRepulsion: {
				nodeDistance: 300
			}
		},
		navigation: true,
		keyboard: true,
		//configurePhysics: true,

		dataManipulation: true, // http://visjs.org/docs/network.html#Data_manipulation_custom

		onAdd: function(data, callback) {
			log('onAdd ' + JSON.stringify(data));
			//alert("Create new key pair or import key from keyserver?");
			// TODO: Let User choose between importing key or creating new key pair
			try {
				window.top.enigmailRefreshKeys = function() {}; // We do that ourselves
				window.top.enigmailSearchKeys();
				setTimeout(function() {async.series([
					clearGraph,
					showGraph,
				]);}, 0);
				data.level = 0;
				callback(data);
			} catch (ex) {Components.utils.reportError(ex);log('graph.html: ' + ex);}
		},
		/*
		onEdit: function(data, callback) {
			log('onEdit ' + JSON.stringify(data));
			alert("Update key from keyserver, change owner trust, create signature (see onConnect), ...?");
		},
		*/
		/*
		onEditEdge: function(data, callback) {
			alert("Editing edges does not really make sense!");
		},
		*/
		onConnect: function(edge, callback) {
			log("onConnect: " + JSON.stringify(edge));
			// edge = {from: nodeId1, to: nodeId2};

			var from = data.nodes.get(edge.from).keyObj;
			var to = data.nodes.get(edge.to).keyObj;

			if (from.secretAvailable) {
				//confirm("Create signature " + name + "?")
				try {
					var r = EnigmailFuncs.signKey(window.top, to.userId, to.keyId, null);
					if (r) {
						setTimeout(function() {async.series([
							clearGraph,
							showGraph,
						]);}, 0);
						callback(edge);
					}
				} catch (ex) {Components.utils.reportError(ex); log('onConnect: ' + ex); return;}
			} else {
				// TODO: Show message in statusbar (non-destructive)
				alert("You can only create signatures from a secret key!");
			}
		},      
		onDelete: function(selection, callback) {
			// TODO
			log("onDelete: " + JSON.stringify(selection));
			// selection = {nodes: [selectedNodeIds], edges: [selectedEdgeIds]};
			if (selection.nodes.length > 0) {
				for (var i=0; i<selection.nodes.length; ++i) {
					var keyObj = data.nodes.get(selection.nodes[i]).keyObj;
					if (keyObj.secretAvailable) {
						confirm("Revoke key " + selection.nodes[i] + "?");
					} else {
						confirm("Delete key " + selection.nodes[i] + " from keyring?");
					}
				}
			} else if (selection.edges.length > 0) {
				for (var i=0; i<selection.edges.length; ++i) {
					var edge = data.edges.get(selection.edges[i]);
					var keyObj = data.nodes.get(edge.from).keyObj;
					if (keyObj.secretAvailable) {
						confirm("Revoke signature " + selection.edges[i] + "?")
					} else {
						alert("Can not revoke signature " + selection.edges[i] + "!");
					}
				}
			}
		},
	};

	function setStatus(v, s) {
		if (v) {
			var vv = parseInt(v);
			window.top.document.getElementById("transparentcrypto-graph-progress").value = vv;
			window.top.document.getElementById("transparentcrypto-graph-progress-text").label = vv.toFixed(0) + "%";
		}
		if (s) {
			window.top.document.getElementById("transparentcrypto-graph-statusbarpanel").label = s;
		}
	}

	function init() {
		var container = document.getElementById('container');

		try {
			network = new vis.Network(container, data, options);
		} catch (ex) {Components.utils.reportError(ex);log('graph.html: ' + ex);}

		try {
			//network.on("resize", function(params) {log(params.width,params.height)});
			window.addEventListener("resize", function(target) {
				try {
					network.redraw();
					network.zoomExtent();
				} catch (ex) {Components.utils.reportError(ex);log('graph.html: ' + ex);}
			});

			//network.on('stabilized', function(properties) {log('Stabilized after ' + properties.iterations + ' iterations');});

			network.on('hoverNode', function(properties) {hoverNode = properties.node; window.top.hoverNode = hoverNode;});
			network.on('blurNode', function(properties) {hoverNode = null; window.top.hoverNode = null;});

			//network.on('click', function(properties) {if (properties.nodes.length > 0) alert('click: ' + JSON.stringify(properties.nodes));});
			//network.on('doubleClick', function(properties) {if (properties.nodes.length > 0) alert('doubleClick: ' + JSON.stringify(properties.nodes));});
		} catch (ex) {Components.utils.reportError(ex);log('graph.html: ' + ex);}

		showGraph();

	}

	function showGraph(cb) {
		log("showGraph");

		setTimeout(function() {async.series([
			function(cb) {setTimeout(addKeys, 0, cb);},
			//function(cb) {setTimeout(shuffleNodes, 0, cb);},
			function(cb) {setTimeout(displaySigs, 0, cb);},
		], cb);}, 0);
	}

	function clearGraph(cb) {
		log("clearGraph");

		data.edges.clear();
		data.nodes.clear();

		if (cb)
			cb(null);
	}

	function addKeys(cb) {
		log('graph.html: ' + 'addKeys');

		setStatus(0, "Loading keys...");

		try {
			var keyList = getKeys(window.top);
			gKeyList = keyList.keyListObj.keyList;
			window.top.gKeyList = gKeyList;
			gKeySortList = keyList.keyListObj.keySortList;
			window.top.gKeySortList = gKeySortList;
		} catch (ex) {
			Components.utils.reportError(ex);
			log('graph.html: ' + ex);
			setStatus(0, "An error occured while loading keys...");
			if (cb)
				cb(ex);
			return;
		}

		var secretKeyList = new Array();

		for (var i=0; i < keyList.length; ++i) {
			var keyObj = keyList[i];
			try {
				var node = data.edges.get(keyObj.keyId);
				if (!node) {
					var userId = EnigmailCommon.convertGpgToUnicode(keyObj.userId);
					if (keyObj.secretAvailable)
						secretKeyList.push(keyObj.keyId);
					node = {
						id: keyObj.keyId,
						level: keyTrustLevel.get(keyObj.keyTrust),
						group: keyObj.keyTrust,
						label: userId.replace(" <", "\n<"),
						title: 
							"<b>userId:</b> " + escapeHTML(userId) + "<br />" +
							"<b>keyId:</b> " + keyObj.keyId + "<br />" +
							"<b>keyTrust:</b> " + keyObj.keyTrust + " (" + keyTrustName.get(keyObj.keyTrust) + ")" + "<br />" +
							"<b>ownerTrust:</b> " + keyObj.ownerTrust + "<br />" +
							"<b>secretAvailable:</b> " + keyObj.secretAvailable + "<br />" +
							"<b>created:</b> " + keyObj.created + "<br />" +
							"<b>expiry:</b> " + keyObj.expiry + "<br />" +
							"",
						keyObj: keyObj,
					};
					data.nodes.add(node);
				} else {
					log('Duplicate node for keyId ' + keyObj.keyId + ': ' + JSON.stringify(node));
				}
				var v = 33 * (i/keyList.length);
				setStatus(Math.round(v));
			} catch (ex) {Components.utils.reportError(ex);log('graph.html: ' + ex);}
		}

		log('graph.html: ' + 'Created ' + keyList.length + ' nodes');

		setStatus(33);

		// Create invisible dummy edges for each node to keep them together
		var from = secretKeyList.pop();

		for (var i=0; i < keyList.length; ++i) {
			var keyObj = keyList[i];
			try {
				var to = keyObj.keyId;
				var edgeId = from + '=' + to;
				var edge = data.edges.get(edgeId);
				if (!edge) {
					edge = {
						id: edgeId,
						to: to,
						from: from,
						color: {
							color: "#FFFFFF",
							highlight: "#FFFFFF",
							hover: "#FFFFFF",
						},
						hoverWidth: 1,
						dummy: true,
					};
					data.edges.add(edge);
				} else {
					log('Duplicate dummy edge for edgeId ' + edgeId + ': ' + JSON.stringify(edge));
				}
				var v = 66 + 33 * (i/keyList.length);
				setStatus(Math.round(v));
			} catch (ex) {Components.utils.reportError(ex);log('graph.html: ' + ex);}
		}

		log('graph.html: ' + 'Created ' + keyList.length + ' dummy edges');

		setStatus(66);

		shuffleNodes();

		setStatus(100, "Keys loaded!");

		if (cb)
			cb(null, keyList);

		return keyList;
	}

	function shuffleNodes(cb) {
		// Optimize vertical space consumption
		var groups = data.nodes.distinct("group");

		for (var i=0; i<groups.length; ++i) {
			var group = groups[i];
			var level = keyTrustLevel.get(group);
			var nodes = data.nodes.getIds({filter: function(key) {return (key.group === group)}});
			var nodeLen = nodes.length;
			for (var j=0; j<nodeLen; ++j) {
				if ((nodeLen > 5) && (Math.random() > 0.5)) {
					data.nodes.update({id: nodes[j], level: 2*level+1});
				} else {
					data.nodes.update({id: nodes[j], level: 2*level});
				}
			}
		}

		if (cb)
			cb(null);
	}

	function addSigs(key, cb) {
		log("addSigs: " + JSON.stringify(key));
		var keyId = key.id;

		try {
			log('graph.html: ' + 'getSigs' + ' ' + keyId);
			var sigList = getSigs(window.top, keyId);
		} catch (ex) {
			Components.utils.reportError(ex);
			log('graph.html: ' + ex);
			setStatus(0, "An error occured while loading signatures...");
			if (cb)
				cb(ex);
			return;
		}

		for (var i=0; i < sigList.length; ++i) {
			var entry = sigList[i];
			try {
				//log(JSON.stringify(entry));
				if (entry.type === "sig") {
					var edgeId = keyId + '-' + entry.keyId;
					var edge = data.edges.get(edgeId);
					if (!edge) {
						var userId = EnigmailCommon.convertGpgToUnicode(entry.userId);
						var node = data.nodes.get(entry.keyId);
						if (!node) {
							if (key.keyObj.secretAvailable) {
								log("Missing node for keyId " + entry.keyId);
								// Only create node for missing keys when secretAvailable
								node = {
									id: entry.keyId,
									level: 10,
									group: "o",
									label: userId.replace(" <", "\n<"),
									title: 
										"<b>userId:</b> " + escapeHTML(userId) + "<br />" +
										"<b>keyId:</b> " + entry.keyId + "<br />" +
										"<i>Key not in keyring</i>" +
										"",
								};
								data.nodes.add(node);
							}
						}

						if (node) {
							var toUserId = EnigmailCommon.convertGpgToUnicode(key.keyObj.userId);
							var edge = {
								id: edgeId,
								to: keyId,
								from: entry.keyId,
								//label: edgeId,
								title:
									"<b>For Key:</b> " + key.keyObj.keyId + " (" + escapeHTML(toUserId) + ")<br />" +
									"<b>From Key</b> " + entry.keyId + " (" + escapeHTML(userId) + ")<br />" +
									/*
									"<b>keyValidity:</b> " + entry.keyValidity + "<br />" +
									"<b>ownerTrust:</b> " + entry.ownerTrust + "<br />" +

									"<b>sigType:</b> " + entry.sigType + "<br />" +
									"<b>keyUseFor:</b> " + entry.keyUseFor + "<br />" +
									*/
									"<b>created:</b> " + entry.created + "<br />" +
									"<b>expiry:</b> " + entry.expiry + "<br />" +
									"",
							};
							data.edges.add(edge);
						}
					} else {
						//log("Duplicate edgeId: " + edgeId);
					}
				}
			} catch (ex) {Components.utils.reportError(ex);log('graph.html: ' + ex);}
		}

		if (cb)
			cb(null, sigList);

	}

	function displaySigs(cb) {
		// Add or delete signatures based on radio button
		var showallsigs = document.getElementById('showsigs-all').checked || false;
		var keyList;

		if (showallsigs) 
			keyList = data.nodes.get();
		else
			keyList = data.nodes.get({filter: function(key) {return key.keyObj.secretAvailable}});

		setStatus(0, "Loading signatures...");

		for (var i=0; i < keyList.length; ++i) {
			addSigs(keyList[i]);
			var v = 100 * (i/keyList.length);
			setStatus(Math.round(v));
		}

		setStatus(100, "Signatures loaded");
		
		if (cb)
			cb(null, keyList);
	}

	log("graph.html: " + "loaded");
</script>

</head>

<body onload="init();">
	<div style="width: 100%; height: 100%; display: table;">
		<div id="toolbar" style="width: 100%; display: table-row; font-size: 10pt;">
			<fieldset style="display: inline-block;"><legend>Show Signatures</legend>
				<label><input type="radio" id="showsigs-private" name="showsigs" onchange="displaySigs();" />for Private Keys</label>
				<label><input type="radio" id="showsigs-all" name="showsigs" checked="checked" onchange="displaySigs();" />for all Keys</label>
			</fieldset>
			<button onclick="location.reload();">Reload</button>
			<button onclick="alert('Help is underway...');">Help</button>
		</div>

		<div id="container" style="width: 100%; height: 100%; display: table-row; background: #FFFFFF;"></div>
	</div>
</body>

</html>
