<!-- https://github.com/almende/vis/blob/master/examples/network/24_hierarchical_layout_userdefined.html -->
<!-- http://visjs.org/docs/network.html -->
<!--
TODO: Unbekannte Schlüssel nur für eigene Keys
TODO: Statusbar mit Loading-Hinweis (x/y keys loaded)
-->
<html>
<head>

<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta charset="utf-8">

<script src="resource://transparentcrypto/util.jsm" charset="utf-8"></script>

<script src="chrome://transparentcrypto/content/lib/vis.min.js" charset="utf-8"></script>
<script src="./lib/vis.min.js" charset="utf-8"></script>
<link href="chrome://transparentcrypto/content/lib/vis.min.css" rel="stylesheet" type="text/css" />
<link href="./lib/vis.min.css" rel="stylesheet" type="text/css" />

</head>

<body>

<div id="container" style="width: 100%; height: 100%;"></div>

<script type="text/javascript">

	try {
		Components.utils.import("resource://transparentcrypto/util.jsm");
		Components.utils.import("resource://transparentcrypto/keys.jsm");
		Components.utils.import("resource://enigmail/enigmailCommon.jsm");
	} catch (ex) {log(ex);}

	var container = document.getElementById('container');

	var data = {
	  nodes: new vis.DataSet(),
	  edges: new vis.DataSet(),
	};

	var options = {
		nodes: {
			shape: "box",
			color: "gray",
			allowedToMoveX: true,
			allowedToMoveY: true,
		},
		edges: {
		  style: "arrow",
		  inheritColor: "from",
		  widthSelectionMultiplier: 1.5,
		  color: {
			color: "#848484",
			highlight: "#000000",
		  },
		},
		groups: { // http://colorbrewer2.org/?type=diverging&scheme=RdYlGn&n=7
		  u: { // ultimately valid
			color: "#1a9850",
		  },
		  f: { // fully valid
			color: "#91cf60",
		  },
		  m: { // marginal valid
			color: "#d9ef8b",
		  },
		  n: { // valid
			color: "#ffffbf",
		  },
		  q: { // undefined
			color: "#fee08b",
		  },
		  "-": { // unknown
			color: "#fee08b",
		  },
		  e: { // expired
			color: "#fc8d59",
		  },
		  r: { // revoked
			color: "#fc8d59",
		  },
		  d: { // disabled
			color: "#fc8d59",
		  },
		  i: { // invalid
			color: "#d73027",
		  },
		  o: { // unknown
			color: "#d73027",
		  },
		},
		hierarchicalLayout: {
		  enabled: true,
		  nodeSpacing: 300,
		},
		stabilize: true,
		smoothCurves: true,
		physics: {
			hierarchicalRepulsion: {
				nodeDistance: 300
			}
		},
		navigation: true,
		keyboard: true,
		//configurePhysics: true,

		dataManipulation: true, // http://visjs.org/docs/network.html#Data_manipulation_custom
/*
		onAdd: function(data, callback) {
		  data.level = 1;
		  callback(data);
		},
*/
		onAdd: function(data, callback) {
			alert("Create new key pair or import key from keyserver?");
		},
		onEdit: function(data, callback) {
			alert("Update key from keyserver, change owner trust, create signature (see onConnect)?");
		},
		/*
		onEditEdge: function(data, callback) {
			alert("Editing edges does not really make sense!");
		},
		*/
		onConnect: function(edge, callback) {
			log("onConnect: " + JSON.stringify(edge));
			// edge = {from: nodeId1, to: nodeId2};
			var keyObj = data.nodes.get(edge.from).keyObj;
			var name = edge.from + "-" + edge.to;
			if (keyObj.secretAvailable) {
				confirm("Create signature " + name + "?")
			} else {
				alert("Can not create signature " + name + "!");
			}
		},      
		onDelete: function(selection, callback) {
			log("onDelete: " + JSON.stringify(selection));
			// selection = {nodes: [selectedNodeIds], edges: [selectedEdgeIds]};
			if (selection.nodes.length > 0) {
				for (var i=0; i<selection.nodes.length; ++i) {
					var keyObj = data.nodes.get(selection.nodes[i]).keyObj;
					if (keyObj.secretAvailable) {
						confirm("Revoke key " + selection.nodes[i] + "?");
					} else {
						confirm("Delete key " + selection.nodes[i] + " from keyring?");
					}
				}
			} else if (selection.edges.length > 0) {
				for (var i=0; i<selection.edges.length; ++i) {
					var edge = data.edges.get(selection.edges[i]);
					var keyObj = data.nodes.get(edge.from).keyObj;
					if (keyObj.secretAvailable) {
						confirm("Revoke signature " + selection.edges[i] + "?")
					} else {
						alert("Can not revoke signature " + selection.edges[i] + "!");
					}
				}
			}
		},

	};

	try {
	  var network = new vis.Network(container, data, options);
	  //network.on("resize", function(params) {log(params.width,params.height)});
	  window.addEventListener("resize", function(target) {
		  try {
			network.redraw();
			network.zoomExtent();
		  } catch (ex) {log(ex);}
		});
	  network.on('click', function(properties) {if (properties.nodes.length > 0) alert('click: ' + JSON.stringify(properties.nodes));});
	  network.on('doubleClick', function(properties) {if (properties.nodes.length > 0) alert('doubleClick: ' + JSON.stringify(properties.nodes));});
	} catch (ex) {log(ex);}

	log("graph.html: " + "loaded");

    document.addEventListener('contextmenu', function(e) {
        alert('Contextmenu: Currently selected: ' + JSON.stringify(network.getSelection()));
        e.preventDefault();
    }, false);

	//window.onload = function() {
	window.setTimeout(function() {
		var nodemap = {}, edgemap = {};

		var data_vis = {
			nodes: [],
			edges: [],
		};

		function addKeys() {
			try {
				log('graph.html: ' + 'getKeys')
				var keyList = getKeys(window.top);
			} catch (ex) {Components.utils.reportError(ex); log('graph.html: ' + ex);}

			for (var i=0; i < keyList.length; ++i) {
				var keyObj = keyList[i];
				try {
					if (!nodemap[keyObj.keyId]) {
						var userId = EnigmailCommon.convertGpgToUnicode(keyObj.userId);
						nodemap[keyObj.keyId] = i;  // NodeIdx
						var node = {
							id: keyObj.keyId,
							level: keyTrustLevel.get(keyObj.keyTrust),
							group: keyObj.keyTrust,
							label: userId.replace(" <", "\n<"),
							title: "<b>userId:</b> " + escapeHTML(userId) + "<br />" +
								"<b>keyId:</b> " + keyObj.keyId + "<br />" +
								"<b>keyTrust:</b> " + keyObj.keyTrust + " (" + keyTrustName.get(keyObj.keyTrust) + ")" + "<br />" +
								"<b>ownerTrust:</b> " + keyObj.ownerTrust + "<br />" +
								"<b>secretAvailable:</b> " + keyObj.secretAvailable + "<br />" +
								"<b>created:</b> " + keyObj.created + "<br />" +
								"<b>expiry:</b> " + keyObj.expiry + "<br />" +
								"",
							keyObj: keyObj,
						};
						//data_vis.nodes.push(node);
						data.nodes.add(node);
					} else {log('Duplicate node keyId: ' + keyObj.keyId);}
				} catch (ex) {Components.utils.reportError(ex);log('graph.html: ' + ex);}
			}
			return keyList;
		}

		window.top.document.getElementById("transparentcrypto-graph-progress").value = 0;
		window.top.document.getElementById("transparentcrypto-graph-progress-text").label = "0%";
		window.top.document.getElementById("transparentcrypto-graph-statusbarpanel").label = "Keys loaded";

		var keyList = addKeys();

		function shuffleNodes() {
			// Optimize vertical space consumption
			var groups = data.nodes.distinct("group");

			for (var i=0; i<groups.length; ++i) {
				var group = groups[i];
				var level = keyTrustLevel.get(group);
				var nodes = data.nodes.getIds({filter: function(key) {return (key.group === group)}});
				var nodeLen = nodes.length;
				for (var j=0; j<nodeLen; ++j) {
					if ((nodeLen > 5) && (Math.random() > 0.5)) {
						data.nodes.update({id: nodes[j], level: 2*level+1});
					} else {
						data.nodes.update({id: nodes[j], level: 2*level});
					}
				}
			}
		}

		shuffleNodes();

		window.top.document.getElementById("transparentcrypto-graph-progress").value = 10;
		window.top.document.getElementById("transparentcrypto-graph-progress-text").label = "10%";
		window.top.document.getElementById("transparentcrypto-graph-statusbarpanel").label = "Keys loaded";

		var keyIdx = 0, keyListLen = keyList.length;

		function addSigs(key) {
			var keyId = key.id;

			var t = nodemap[keyId];

			try {
				log('graph.html: ' + 'getSigs' + ' ' + keyId)
				var sigList = getSigs(window.top, keyId);
			} catch (ex) {Components.utils.reportError(ex); log('graph.html: ' + ex);}

			for (var i=0; i < sigList.length; ++i) {
				var entry = sigList[i];
				try {
					//log(JSON.stringify(entry));
					if (entry.type === "sig") {
						var edgeId = keyId + '-' + entry.keyId;
						if (!edgemap[edgeId]) {
							edgemap[edgeId] = true;
							var nodeIdx = nodemap[entry.keyId];
							if (!nodeIdx) {
								log("Missing node for " + entry.keyId);
								if (key.keyObj.secretAvailable) {
									nodeIdx = Object.keys(nodemap).length;
									nodemap[entry.keyId] = nodeIdx;
									var userId = EnigmailCommon.convertGpgToUnicode(entry.userId);
									var node = {
										id: entry.keyId,
										level: 10,
										group: "o",
										label: userId.replace(" <", "\n<"),
										title: "<b>userId:</b> " + escapeHTML(userId) + "<br />" +
											"<b>keyId:</b> " + entry.keyId + "<br />" +
											"",
									};
									//data_vis.nodes.push(node);
									data.nodes.add(node);
								}
							}

							if (nodeIdx) {
								var edge = {
									id: edgeId,
									to: keyId,
									from: entry.keyId,
								};
								//data_vis.edges.push(edge);
								data.edges.add(edge);
							}
						} else {log("Duplicate edgeId: " + edgeId);}
					}
				} catch (ex) {Components.utils.reportError(ex);log('graph.html: ' + ex);}
			}

			var v = 10 + 90 * (keyIdx/keyListLen);
			log('### ' + v);
			window.top.document.getElementById("transparentcrypto-graph-progress").value = Math.round(v);
			window.top.document.getElementById("transparentcrypto-graph-progress-text").label = Math.round(v) + "%";
			keyIdx++;
		}

		//data.nodes.forEach(addSigs);

		window.setTimeout(function() {
			window.top.document.getElementById("transparentcrypto-graph-statusbarpanel").label="Loading signatures...";
			data.nodes.forEach(addSigs, {filter: function(key) {return key.keyObj.secretAvailable}});
			//data.nodes.forEach(addSigs, {filter: function(key) {return !key.keyObj.secretAvailable}});
			window.top.document.getElementById("transparentcrypto-graph-progress").value = 100;
			window.top.document.getElementById("transparentcrypto-graph-progress-text").label = "100%";
			window.top.document.getElementById("transparentcrypto-graph-statusbarpanel").label="Signatures loaded";
		}, 2000);
	}, 1000);

	//log(JSON.stringify(nodemap));
	//log(JSON.stringify(edgemap));

	//data.nodes.add(data_vis.nodes);
	//data.edges.add(data_vis.edges);

</script>

</body>

</html>
