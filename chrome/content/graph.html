<!-- https://github.com/almende/vis/blob/master/examples/network/24_hierarchical_layout_userdefined.html -->
<!-- http://visjs.org/docs/network.html -->
<!--
TODO: Unbekannte Schlüssel nur für eigene Keys
TODO: Statusbar mit Loading-Hinweis (x/y keys loaded)
-->
<html>
<head>

<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta charset="utf-8">

<!--<script src="resource://transparentcrypto/util.jsm" charset="utf-8"></script>-->

<script type="text/javascript" src="chrome://transparentcrypto/content/lib/async.js"></script>
<script src="chrome://transparentcrypto/content/lib/vis.min.js" charset="utf-8"></script>
<script src="./lib/vis.min.js" charset="utf-8"></script>
<link href="chrome://transparentcrypto/content/lib/vis.min.css" rel="stylesheet" type="text/css" />
<link href="./lib/vis.min.css" rel="stylesheet" type="text/css" />

<script type="text/javascript">

try{

	try {
		Components.utils.import("resource://transparentcrypto/util.jsm");
		Components.utils.import("resource://transparentcrypto/keys.jsm");
		Components.utils.import("resource://enigmail/enigmailCommon.jsm");
	} catch (ex) {log(ex);}

	var network;

	var data = {
	  nodes: new vis.DataSet(),
	  edges: new vis.DataSet(),
	};

	var nodemap = {}, edgemap = {}, dummyedgemap = {};

	var options = {
		nodes: {
			shape: "box",
			color: "gray",
			allowedToMoveX: true,
			allowedToMoveY: true,
		},
		edges: {
		  style: "arrow",
		  inheritColor: "from",
		  widthSelectionMultiplier: 1.5,
		  color: {
			color: "#848484",
			highlight: "#000000",
		  },
		},
		groups: { // http://colorbrewer2.org/?type=diverging&scheme=RdYlGn&n=7
		  u: { // ultimately valid
			color: "#1a9850",
		  },
		  f: { // fully valid
			color: "#91cf60",
		  },
		  m: { // marginal valid
			color: "#d9ef8b",
		  },
		  n: { // valid
			color: "#ffffbf",
		  },
		  q: { // undefined
			color: "#fee08b",
		  },
		  "-": { // unknown
			color: "#fee08b",
		  },
		  e: { // expired
			color: "#fc8d59",
		  },
		  r: { // revoked
			color: "#fc8d59",
		  },
		  d: { // disabled
			color: "#fc8d59",
		  },
		  i: { // invalid
			color: "#d73027",
		  },
		  o: { // unknown
			color: "#d73027",
		  },
		},
		hierarchicalLayout: {
		  enabled: true,
		  nodeSpacing: 300,
		},
		stabilize: true,
		smoothCurves: true,
		physics: {
			hierarchicalRepulsion: {
				nodeDistance: 300
			}
		},
		navigation: true,
		keyboard: true,
		//configurePhysics: true,

		dataManipulation: true, // http://visjs.org/docs/network.html#Data_manipulation_custom
/*
		onAdd: function(data, callback) {
		  data.level = 1;
		  callback(data);
		},
*/
		onAdd: function(data, callback) {
			alert("Create new key pair or import key from keyserver?");
		},
		onEdit: function(data, callback) {
			alert("Update key from keyserver, change owner trust, create signature (see onConnect)?");
		},
		/*
		onEditEdge: function(data, callback) {
			alert("Editing edges does not really make sense!");
		},
		*/
		onConnect: function(edge, callback) {
			log("onConnect: " + JSON.stringify(edge));
			// edge = {from: nodeId1, to: nodeId2};
			var keyObj = data.nodes.get(edge.from).keyObj;
			var name = edge.from + "-" + edge.to;
			if (keyObj.secretAvailable) {
				confirm("Create signature " + name + "?")
			} else {
				alert("Can not create signature " + name + "!");
			}
		},      
		onDelete: function(selection, callback) {
			log("onDelete: " + JSON.stringify(selection));
			// selection = {nodes: [selectedNodeIds], edges: [selectedEdgeIds]};
			if (selection.nodes.length > 0) {
				for (var i=0; i<selection.nodes.length; ++i) {
					var keyObj = data.nodes.get(selection.nodes[i]).keyObj;
					if (keyObj.secretAvailable) {
						confirm("Revoke key " + selection.nodes[i] + "?");
					} else {
						confirm("Delete key " + selection.nodes[i] + " from keyring?");
					}
				}
			} else if (selection.edges.length > 0) {
				for (var i=0; i<selection.edges.length; ++i) {
					var edge = data.edges.get(selection.edges[i]);
					var keyObj = data.nodes.get(edge.from).keyObj;
					if (keyObj.secretAvailable) {
						confirm("Revoke signature " + selection.edges[i] + "?")
					} else {
						alert("Can not revoke signature " + selection.edges[i] + "!");
					}
				}
			}
		},

	};


	function setProgress(v) {
		var vv = parseInt(v);
		window.top.document.getElementById("transparentcrypto-graph-progress").value = vv;
		window.top.document.getElementById("transparentcrypto-graph-progress-text").label = vv.toFixed(0) + "%";
	}

	function setStatusbar(s) {
		window.top.document.getElementById("transparentcrypto-graph-statusbarpanel").label = s;
	}

	function init() {

		var container = document.getElementById('container');

		try {
		 	network = new vis.Network(container, data, options);
		} catch (ex) {Components.utils.reportError(ex);log('graph.html: ' + ex);}

		try {
			//network.on("resize", function(params) {log(params.width,params.height)});
			window.addEventListener("resize", function(target) {
				try {
					network.redraw();
					network.zoomExtent();
				} catch (ex) {Components.utils.reportError(ex);log('graph.html: ' + ex);}
			});

			//network.on('stabilized', function(properties) {log('Stabilized after ' + properties.iterations + ' iterations');});

			network.on('click', function(properties) {if (properties.nodes.length > 0) alert('click: ' + JSON.stringify(properties.nodes));});

			network.on('doubleClick', function(properties) {if (properties.nodes.length > 0) alert('doubleClick: ' + JSON.stringify(properties.nodes));});

			document.addEventListener('contextmenu', function(e) {
			    alert('Contextmenu: Currently selected: ' + JSON.stringify(network.getSelection()));
			    e.preventDefault();
			}, false);

		} catch (ex) {Components.utils.reportError(ex);log('graph.html: ' + ex);}

		setTimeout(function() {async.series([
			function(cb) {setTimeout(addKeys, 0, cb);},
			function(cb) {setTimeout(displaySigs, 0, cb);},
		]);}, 0);
	}

	function addKeys(cb) {
		log('graph.html: ' + 'addKeys');

		setProgress(0);
		setStatusbar("Loading keys...");

		try {
			var keyList = getKeys(window.top);
		} catch (ex) {
			Components.utils.reportError(ex);
			log('graph.html: ' + ex);
			if (cb)
				cb(ex);
			return;
		}

		var secretKeyList = new Array();

		for (var i=0; i < keyList.length; ++i) {
			var keyObj = keyList[i];
			try {
				if (!nodemap[keyObj.keyId]) {
					var userId = EnigmailCommon.convertGpgToUnicode(keyObj.userId);
					nodemap[keyObj.keyId] = i;  // NodeIdx
					if (keyObj.secretAvailable)
						secretKeyList.push(keyObj.keyId);
					var node = {
						id: keyObj.keyId,
						level: keyTrustLevel.get(keyObj.keyTrust),
						group: keyObj.keyTrust,
						label: userId.replace(" <", "\n<"),
						title: 
							"<b>userId:</b> " + escapeHTML(userId) + "<br />" +
							"<b>keyId:</b> " + keyObj.keyId + "<br />" +
							"<b>keyTrust:</b> " + keyObj.keyTrust + " (" + keyTrustName.get(keyObj.keyTrust) + ")" + "<br />" +
							"<b>ownerTrust:</b> " + keyObj.ownerTrust + "<br />" +
							"<b>secretAvailable:</b> " + keyObj.secretAvailable + "<br />" +
							"<b>created:</b> " + keyObj.created + "<br />" +
							"<b>expiry:</b> " + keyObj.expiry + "<br />" +
							"",
						keyObj: keyObj,
					};
					data.nodes.add(node);
				} else {log('Duplicate node keyId: ' + keyObj.keyId);}
				var v = 33 * (i/keyList.length);
				setProgress(Math.round(v));
			} catch (ex) {Components.utils.reportError(ex);log('graph.html: ' + ex);}
		}

		log('graph.html: ' + 'Created ' + keyList.length + ' nodes');

		setProgress(33);

		// Create invisible dummy edges for each node to keep them together

		var from = secretKeyList[0];

		for (var i=0; i < keyList.length; ++i) {
			var keyObj = keyList[i];
			try {
				var to = keyObj.keyId;
				var edgeId = from + '=' + to;
				if (!dummyedgemap[edgeId]) {
					var edge = {
						id: edgeId,
						to: to,
						from: from,
						color: "#FFFFFF",
						dummy: true,
					};
					dummyedgemap[edgeId] = true;
					data.edges.add(edge);
				} else {log('Duplicate dumm edgeId: ' + edgeId);}
				var v = 66 + 33 * (i/keyList.length);
				setProgress(Math.round(v));
			} catch (ex) {Components.utils.reportError(ex);log('graph.html: ' + ex);}
		}

		log('graph.html: ' + 'Created ' + Object.keys(dummyedgemap).length + ' dummy edges');

		setProgress(66);

		shuffleNodes();

		setProgress(100);
		setStatusbar("Keys loaded!");

		if (cb)
			cb(null, keyList);

		return keyList;
	}

	function shuffleNodes(cb) {
		// Optimize vertical space consumption
		var groups = data.nodes.distinct("group");

		for (var i=0; i<groups.length; ++i) {
			var group = groups[i];
			var level = keyTrustLevel.get(group);
			var nodes = data.nodes.getIds({filter: function(key) {return (key.group === group)}});
			var nodeLen = nodes.length;
			for (var j=0; j<nodeLen; ++j) {
				if ((nodeLen > 5) && (Math.random() > 0.5)) {
					data.nodes.update({id: nodes[j], level: 2*level+1});
				} else {
					data.nodes.update({id: nodes[j], level: 2*level});
				}
			}
		}

		if (cb)
			cb(null);
	}

	function addSigs(key, cb) {
		log("addSigs: " + JSON.stringify(key));
		var keyId = key.id;

		var t = nodemap[keyId];

		try {
			log('graph.html: ' + 'getSigs' + ' ' + keyId);
			var sigList = getSigs(window.top, keyId);
		} catch (ex) {Components.utils.reportError(ex); log('graph.html: ' + ex);}

		for (var i=0; i < sigList.length; ++i) {
			var entry = sigList[i];
			try {
				//log(JSON.stringify(entry));
				if (entry.type === "sig") {
					var edgeId = keyId + '-' + entry.keyId;
					if (!edgemap[edgeId]) {
						edgemap[edgeId] = true;
						var nodeIdx = nodemap[entry.keyId];
						if (!nodeIdx) {
							if (key.keyObj.secretAvailable) {
								log("Missing node for " + entry.keyId);
								// Only create node for missing keys when secretAvailable
								nodeIdx = Object.keys(nodemap).length;
								nodemap[entry.keyId] = nodeIdx;
								var userId = EnigmailCommon.convertGpgToUnicode(entry.userId);
								var node = {
									id: entry.keyId,
									level: 10,
									group: "o",
									label: userId.replace(" <", "\n<"),
									title: "<b>userId:</b> " + escapeHTML(userId) + "<br />" +
										"<b>keyId:</b> " + entry.keyId + "<br />" +
										"",
								};
								data.nodes.add(node);
							}
						}

						if (nodeIdx) {
							var edge = {
								id: edgeId,
								to: keyId,
								from: entry.keyId,
							};
							data.edges.add(edge);
						}
					} else {
						//log("Duplicate edgeId: " + edgeId);
					}
				}
			} catch (ex) {Components.utils.reportError(ex);log('graph.html: ' + ex);}
		}

		if (cb)
			cb(null);

	}

	function delSigs(key, cb) {

		if (cb)
			cb(null);

	}

	function displaySigs(cb) {
		// Add or delete signatures based on radio button
		var showallsigs = document.getElementById('showsigs-all').checked || false;
		var keyList;

		if (showallsigs) 
			keyList = data.nodes.get();
		else
			keyList = data.nodes.get({filter: function(key) {return key.keyObj.secretAvailable}});

		setProgress(0);
		setStatusbar("Loading signatures...");

		for (var i=0; i < keyList.length; ++i) {
			addSigs(keyList[i]);
			var v = 100 * (i/keyList.length);
			setProgress(Math.round(v));
		}

		setProgress(100);
		setStatusbar("Signatures loaded");
		
		if (cb)
			cb(null);
	}

	log("graph.html: " + "loaded");
} catch(ex) {Components.utils.reportError(ex);log('graph.html: ' + ex);}
</script>

</head>

<body onload="init();">

<div id="toolbar" style="font-size: 10pt">
	<fieldset><legend>Show Signatures</legend>
		<label><input type="radio" id="showsigs-private" name="showsigs" checked="checked" onclick="displaySigs();" />for Private Keys</label>
		<label><input type="radio" id="showsigs-all" name="showsigs" onclick="displaySigs();" />for all Keys</label>
	</fieldset>
</div>

<div id="container" style="width: 100%; height: 100%; background: #FFFFFF;"></div>

</body>

</html>
